import random
from typing import Sequence

from flanker_ai.i_ai_policy import IAiPolicy
from flanker_ai.i_representation_state import IRepresentationState
from flanker_ai.actions import AssaultAction, FireAction, MoveAction
from flanker_core.gamestate import GameState


class RandomHeuristicPolicy[TAction](IAiPolicy[TAction]):
    """
    Random Heuristic baseline agent. This code is generated by ChatGPT.
    Logic:
    1. If an enemy is in LOF, Fire.
    2. Else, move a random distance along a vector towards the nearest enemy.

    It searches through the representation and finds the action that
    best match the heuristic criteria.
    """

    def __init__(
        self,
        gs: GameState,  # Needed for deabstraction
    ) -> None:
        self._raw_gs = gs

    def get_action_sequence(self, rs: IRepresentationState[TAction]) -> Sequence[TAction]:

        winner = rs.get_winner()
        if winner is not None:
            return []

        actions = list(rs.get_actions())
        if not actions:
            return []

        # Categorizes actions into candidante fire actions or move actions
        fire_actions: list[TAction] = []
        move_actions: list[TAction] = []
        for action in actions:
            result = rs.get_deterministic_branch(action)
            if result == None:  # Ignore invalid actions
                continue

            real_action = rs.deabstract_action(action, self._raw_gs)

            match real_action:
                case FireAction():
                    fire_actions.append(action)
                case MoveAction():
                    move_actions.append(action)
                case AssaultAction():
                    move_actions.append(action)

        # If any fire actions are valid, perform it
        if fire_actions:
            return [random.choice(fire_actions)]

        # Fallback: if any move actions are valid, perform it
        if move_actions:
            return [random.choice(move_actions)]

        # No valid action
        return []
